<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>在Ubuntu上遇到的一些问题</title>
      <link href="/2021/09/19/zai-ubuntu-shang-yu-dao-de-yi-xie-wen-ti/"/>
      <url>/2021/09/19/zai-ubuntu-shang-yu-dao-de-yi-xie-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="1-解决ubuntu-bash-cd-bin-Permission-denied问题"><a href="#1-解决ubuntu-bash-cd-bin-Permission-denied问题" class="headerlink" title="1.解决ubuntu -bash: cd: bin/: Permission denied问题"></a>1.解决ubuntu -bash: cd: bin/: Permission denied问题</h2><p>出现这个问题的原因是因为没有权限，修改一下目录的权限即可</p><p>命令：<code>sudo chmod 777 目录</code></p><p>修改该目录权限为others，group，user都有读和可执行权限</p><h2 id="2-Ubuntu报”有线连接未托管”"><a href="#2-Ubuntu报”有线连接未托管”" class="headerlink" title="2.Ubuntu报”有线连接未托管”"></a>2.Ubuntu报”有线连接未托管”</h2><p>可能有效的方法<a href="https://blog.csdn.net/daerzei/article/details/85058130">点击进去</a></p><h2 id="3-给Ubuntu上的pycharm设置快捷方式"><a href="#3-给Ubuntu上的pycharm设置快捷方式" class="headerlink" title="3.给Ubuntu上的pycharm设置快捷方式"></a>3.给Ubuntu上的pycharm设置快捷方式</h2><ul><li>仅供参考，视你pycharm的相关安装路径而定</li></ul><p>1.<code>sudo vi /usr/share/applications/Pycharm.desktop</code><br>2.输入以下代码，在文件位置需要修改</p><pre class="line-numbers language-none"><code class="language-none">[Desktop Entry]Type&#x3D;ApplicationName&#x3D;PycharmGenericName&#x3D;Pycharm5Comment&#x3D;Pycharm5:The Python IDE Exec&#x3D;&quot;&#x2F;home&#x2F;usr_name&#x2F;pycharm-2018.1.4&#x2F;bin&#x2F;pycharm.sh&quot; %f  #设置自己的pycham路径Icon&#x3D;&#x2F;home&#x2F;usr_name&#x2F;pycharm-2018.1.4&#x2F;bin&#x2F;pycharm.png #图标的位置Terminal&#x3D;false #打开程序时是否同时打开命令行，建议关闭Categories&#x3D;Pycharm #Categories这里的内容决定创建出的起动器在应用程序菜单中的位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.保存后退出，即可在搜索得到</p><ul><li>注：如果下载的是pycharm专业版，可直接在pycharm里面点击<strong>Tools</strong>,再点击<strong>Creat Desktop Entry</strong>即可(如果想创建root权限的快捷方式，得从命令行用sudo方式打开pycharm)</li></ul><h2 id="4-ping在linux上的不同"><a href="#4-ping在linux上的不同" class="headerlink" title="4.ping在linux上的不同"></a>4.ping在linux上的不同</h2><p>linux下的ping和windows下的ping稍有区别,linux下ping不会自动终止,需要按ctrl+c终止或者用参数-c指定要求完成的回应次数.下面是ping命令的一些选项：</p><blockquote><p>-d：使用Socket的SO_DEBUG功能；<br>-c&lt;完成次数&gt;：设置完成要求回应的次数；<br>-f：极限检测；<br>-i&lt;间隔秒数&gt;：指定收发信息的间隔时间；<br>-I&lt;网络界面&gt;：使用指定的网络界面送出数据包；<br>-l&lt;前置载入&gt;：设置在送出要求信息之前，先行发出的数据包；<br>-n：只输出数值；<br>-p&lt;范本样式&gt;：设置填满数据包的范本样式；<br>-q：不显示指令执行过程，开头和结尾的相关信息除外；<br>-r：忽略普通的Routing Table，直接将数据包送到远端主机上；<br>-R：记录路由过程；<br>-s&lt;数据包大小&gt;：设置数据包的大小；<br>-t&lt;存活数值&gt;：设置存活数值TTL的大小；<br>-v：详细显示指令的执行过程。</p></blockquote><h2 id="5-ubuntu突然不能上网"><a href="#5-ubuntu突然不能上网" class="headerlink" title="5.ubuntu突然不能上网"></a>5.ubuntu突然不能上网</h2><p>亲测有效<a href="https://blog.csdn.net/nicker08/article/details/103093638">点击进去</a><br>        <a href="https://www.pianshen.com/article/81971052661/">点击进去2</a> </p><h2 id="6-apt-get-提示-无法解析域名“cn-archive-ubuntu-com”-的解决"><a href="#6-apt-get-提示-无法解析域名“cn-archive-ubuntu-com”-的解决" class="headerlink" title="6.apt-get 提示 无法解析域名“cn.archive.ubuntu.com” 的解决"></a>6.apt-get 提示 无法解析域名“cn.archive.ubuntu.com” 的解决</h2><p>忘了是在啥情况下遇到的这个问题了。。。<a href="https://blog.csdn.net/wuzhidefeng/article/details/80540188">点击进去</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu改成桥接模式的一些尝试</title>
      <link href="/2021/09/17/ubuntu-gai-cheng-qiao-jie-mo-shi-de-yi-xie-chang-shi/"/>
      <url>/2021/09/17/ubuntu-gai-cheng-qiao-jie-mo-shi-de-yi-xie-chang-shi/</url>
      
        <content type="html"><![CDATA[<p>看到的一个感觉挺简洁的方法<a href="https://blog.csdn.net/weixin_42627397/article/details/110826285?utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.searchformbaiduhighlight&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.searchformbaiduhighlight">简便方法</a>.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>用python实现traceroute</title>
      <link href="/2021/09/16/yong-python-shi-xian-traceroute/"/>
      <url>/2021/09/16/yong-python-shi-xian-traceroute/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>本次用python实现traceroute，主要用到了socket,struct,select,还需要对ICMP报文有足够的了解，以及校验和算法的实现。</p><h2 id="2-ICMP协议"><a href="#2-ICMP协议" class="headerlink" title="2.ICMP协议"></a>2.ICMP协议</h2><p>TraceRoute程序的实现一般可基于ICMP和UDP两种协议来实现，这里我采用的是前者。</p><h2 id="2-1简介"><a href="#2-1简介" class="headerlink" title="2.1简介"></a>2.1简介</h2><p>ICMP（Internet Control Message Protocol），中文译作网际控制报文协议，它允许主机或路由器报告差错情况和提供有关异常情况的报告，其常用功能有：确认IP数据报是否成功送达目标地址、通知在发送过程中IP数据报被废弃的原因，改善网络设置等。<br>ICMP报文虽封装在IP数据报中，但它并不属于更高层协议，反而仍属于网络层协议。下面是网络层各协议的层次分布情况，其上下关系说明了协议之间的依赖关系（上面的高层协议依赖于下面的低层协议），比如说IP协议就依赖于ARP协议的地址解析功能，ICMP和IGMP协议就依赖于IP协议的交付功能。<br><img src="https://i.loli.net/2021/09/18/tTCO1Gf3WRboqAc.jpg" alt="ip层.jpg"></p><h2 id="2-2报文格式"><a href="#2-2报文格式" class="headerlink" title="2.2报文格式"></a>2.2报文格式</h2><p>下图是ICMP报文的格式，简单介绍了各字段占用字节的大小，接下来还需要详细介绍一下各字段表示的意义：</p><p>类型（type）：标识ICMP报文的类型。</p><p>代码（code）：用于进一步区分某种类型中的某种情况。</p><p>校验和（checksum）：用于保证ICMP报文的完整性和正确性。<br><img src="https://i.loli.net/2021/09/18/WKkGioC1YI5Vgad.jpg" alt="ICMP.jpg"></p><p>不同之处在于整个第二行的全部四个字节，其具体内容要根据ICMP报文类型的变化而具备不同意义：</p><p>当报文类型为回送请求时， 前两个字节表示id（标识符），后两个字节表示sequence（序列号）。</p><p>当报文类型为回送应答时，这四个字节会原封不动地返回源主机。</p><p>当报文类型为超时报文时，这四个字节必须强制填充为 0 。</p><p>当报文类型为参数错误时，第一个字节作为指针指向出错部分，后三个字节强制填充为 0 。</p><ul><li>注：ICMP报文需要计算校验和是由于：IP数据报计算的校验和只针对IP数据报首部有效，并不能确保数据部分一定进行无差错传输，类似地，TCP和UDP也需要自行计算校验和以确保数据部分的无差错传输。</li></ul><h2 id="2-3报文分类"><a href="#2-3报文分类" class="headerlink" title="2.3报文分类"></a>2.3报文分类</h2><p>ICMP报文主要分为两大类 - 差错报告报文和网络控制报文：差错报告报文由于责任重大，规定其数据区必须包括发生差错的IP数据报首部以及数据区的至少64比特，因为这些信息更够为源端采取差错处理措施提供依据。</p><p>网络控制报文又可分为两类 - 请求/应答报文和通知报文：其中请求/应答报文总是成对出现的，一个负责请求，一个负责应答，而通知报文顾名思义，则只负责建立一种单向的通知机制。</p><p>ICMP报文种类繁多，协议设计者按照层次将其划分为type和code两层结构，其中type字段表明ICMP报文的类型，code字段则提供了有关报文类型更为详细的信息，下面是不同type值所代表的意义：<br><img src="https://i.loli.net/2021/09/18/ihaJeBzLCmKwRO3.jpg" alt="ICMP报文类型.jpg"></p><p>确定了type之后，还需要确定code：如果当前type已经无需再进行细分的话，则置为 0 即可；但常见的诸如type为3、5、11、12 等的报文是还需细分的，具体的划分情况请看下表：</p><table><thead><tr><th>type</th><th>code</th><th>meaning</th><th>code</th><th>meaning</th></tr></thead><tbody><tr><td>03 - 目的站不可达</td><td>0</td><td>目的网络不可达</td><td>8</td><td>源主机隔离</td></tr><tr><td></td><td>1</td><td>目的主机不可达</td><td>9</td><td>禁止访问的网络</td></tr><tr><td></td><td>2</td><td>目的协议不可达</td><td>10</td><td>机制访问的主机</td></tr><tr><td></td><td>3</td><td>目的端口不可达</td><td>11</td><td>对特定TOS网络不可达</td></tr><tr><td></td><td>4</td><td>要求分段并置DF标志位</td><td>12</td><td>对特定TOS主机不可达</td></tr><tr><td></td><td>5</td><td>源路由失败</td><td>13</td><td>由于过滤，网络流量被禁止</td></tr><tr><td></td><td>6</td><td>目的网络未知</td><td>14</td><td>主机越权</td></tr><tr><td></td><td>7</td><td>目的主机未知</td><td>15</td><td>优先权终止生效</td></tr><tr><td>05  重定向</td><td>0</td><td>重定向网络</td><td>2</td><td>基于TOS的网络重定向</td></tr><tr><td></td><td>1</td><td>重定向主机</td><td>3</td><td>基于TOS的主机重定向</td></tr><tr><td>11 - 报文超时</td><td>0</td><td>TTL超时</td><td>1</td><td>分片重组超时</td></tr><tr><td>12 - 参数问题</td><td>0</td><td>IP数据报首部参数错误</td><td>2</td><td>不支持的长度</td></tr><tr><td></td><td>1</td><td>丢失必要选项</td><td></td><td></td></tr></tbody></table><ul><li>注：TOS（Type of Service），中文可译为请求的服务类型。</li></ul><h2 id="3-TraceRoute程序的基本原理是："><a href="#3-TraceRoute程序的基本原理是：" class="headerlink" title="3.TraceRoute程序的基本原理是："></a>3.TraceRoute程序的基本原理是：</h2><p>当路由器收到一份IP数据报，如果该报文的TTL字段是1，则意味着它在网路中的生存周期已经消耗殆尽，<br>本路由处理后还未到达目的主机的话，需要将该数据报丢弃，并给信源主机发送一份ICMP超时报文（包含该中间路由器的地址）。<br>这意味着：通过发送一份TTL字段为n的IP数据报给目的主机，就得到了该路径中的第n个路由器的IP地址。<br>那么我们使IP数据报的TTL字段值从1开始依次递增(一般最大不超过30)，就可以获得所有中间路由的ip地址。<br>当IP数据报到达目的主机时，由于已经到达目的主机，因此不会再发送ICMP超时报文了，而是ICMP应答报文。<br>通过区分收到的ICMP报文是超时报文（type=11）还是应答报文（type=0），以判断程序应该何时结束。</p><ul><li><p>因此，要实现一个traceroute程序，主要需要以下几大步骤<br>  1.创建原始套接字（注意：原始套接字需要管理员（root）权限，在linux下如果不用sudo运行，会报出<strong>PermissionError: [Errno 1] Operation not permitted</strong>的错误）</p><p>  2.构建ICMP报文,ICMP报文内容如下：<br>  ————————————————————————————————————————<br>  |type (8) | code (8) | checksum (16)   |<br>  ————————————————————————————————————————<br>  |        id (16)     |  seq (16)       |<br>  ————————————————————————————————————————</p><p>  3.选取合适的校验和算法，用于ICMP报文的构造</p></li></ul><h2 id="4-原始套接字"><a href="#4-原始套接字" class="headerlink" title="4.原始套接字"></a>4.原始套接字</h2><p>所谓套接字(Socket)，就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议根进行交互的接口。套接字可分为流式套接字，数据包套接字以及原始套接字。<br>原始套接字与标准套接字(标准套接字指的是流式套接字和数据报套接字)的区别在于：原始套接字可以读写内核没有处理的IP数据包，而流式套接字只能读取TCP协议的数据，数据报套接字只能读取UDP协议的数据。因此，如果要访问其他协议发送的数据必须使用原始套接字。而本次使用的是ICMP协议（运行在网络层），故只能使用原始套接字来实现功能。</p><blockquote><p>AF_INET: ipv4 格式的 ip 地址<br>AF_INET6: ipv6 格式的 ip 地址</p></blockquote><h2 id="5-字节序"><a href="#5-字节序" class="headerlink" title="5.字节序"></a>5.字节序</h2><p>在各种计算机体系结构中，对于字节、字等的存储机制有所不同，因而引发了计算机通信领域中一个很重要的问题，即通信双方交流的信息单元（比特、字节、字、双字等等）应该以什么样的顺序进行传送。如果不达成一致的规则，通信双方将无法进行正确的编 / 译码从而导致通信失败。</p><p>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，也就是说对于单字符来说是没有字节序问题的，字符串是单字符的集合，因此字符串也没有字节序问题。</p><p>目前在各种体系的计算机中通常采用的字节存储机制主要有两种：Big-Endian 和 Little-Endian</p><ul><li>Little-Endian -&gt; 主机字节序 (小端)</li></ul><blockquote><p>数据的低位字节存储到内存的低地址位 , 数据的高位字节存储到内存的高地址位<br>我们使用的 PC 机，数据的存储默认使用的是小端</p></blockquote><ul><li>Big-Endian -&gt; 网络字节序 (大端)</li></ul><blockquote><p>数据的低位字节存储到内存的高地址位 , 数据的高位字节存储到内存的低地址位<br>套接字通信过程中操作的数据都是大端存储的(因此需要函数转换一下)，包括：接收/发送的数据、IP地址、端口。</p></blockquote><h2 id="6-struct"><a href="#6-struct" class="headerlink" title="6.struct"></a>6.struct</h2><p>有的时候需要用python处理二进制数据，比如，存取文件，socket操作时.这时候，可以使用python的struct模块来完成.<br>struct模块中最重要的三个函数是pack(), unpack(), calcsize()<br>pack(fmt, v1, v2, …)     按照给定的格式(fmt)，把数据封装成字符串(实际上是类似于c结构体的字节流)</p><p>unpack(fmt, string)       按照给定的格式(fmt)解析字节流string，返回解析出来的tuple</p><p>calcsize(fmt)                 计算给定的格式(fmt)占用多少字节的内存<br>struct中支持的格式如下表：</p><table><thead><tr><th>Format</th><th>C Type</th><th>Python</th><th>字节数</th></tr></thead><tbody><tr><td>x</td><td>pad byte</td><td>no value</td><td>1</td></tr><tr><td>c</td><td>char</td><td>string of length 1</td><td>1</td></tr><tr><td>b</td><td>signed char</td><td>integer</td><td>1</td></tr><tr><td>B</td><td>unsigned char</td><td>integer</td><td>1</td></tr><tr><td>?</td><td>_Bool</td><td>bool</td><td>1</td></tr><tr><td>h</td><td>short</td><td>integer</td><td>2</td></tr><tr><td>H</td><td>unsigned short</td><td>integer</td><td>2</td></tr><tr><td>i</td><td>int</td><td>integer</td><td>4</td></tr><tr><td>I</td><td>unsigned int</td><td>integer or long</td><td>4</td></tr><tr><td>l</td><td>long</td><td>integer</td><td>4</td></tr><tr><td>L</td><td>unsigned long</td><td>long</td><td>4</td></tr><tr><td>q</td><td>long long</td><td>long</td><td>8</td></tr><tr><td>Q</td><td>unsigned long long</td><td>long</td><td>8</td></tr><tr><td>f</td><td>float</td><td>float</td><td>4</td></tr><tr><td>d</td><td>double</td><td>float</td><td>8</td></tr><tr><td>s</td><td>char[]</td><td>string</td><td>1</td></tr><tr><td>p</td><td>char[]</td><td>string</td><td>1</td></tr><tr><td>P</td><td>void *</td><td>long</td><td></td></tr></tbody></table><h2 id="7-校验和算法"><a href="#7-校验和算法" class="headerlink" title="7.校验和算法"></a>7.校验和算法</h2><p>校验和算法的实现是最大的难点，尤其是在Python这种声明了一个变量都不知道它占多少字节的语言中。先简要说明一下计算校验和的流程。</p><blockquote><p>1.初始化校验和为 0 ，填充至首部后，将首部和数据部分组合在一起作为check_sun函数的参数。<br>2.利用函数计算出真正的校验和。<br>3.转换主机序（一般为小端）为网络序（统一为大端）。<br>4.重新填充到首部后，发送即可。</p></blockquote><p>主要内容是二进制反码求和，其中一种思路为：</p><blockquote><p>先确认字节流长度是否为2的倍数，若不是则认为添加使其为2的倍数<br>按照两个字节为一组依次求和<br>将高 16 位上的进位加到低 16 位上，重复 2 次，即可确保高 16 位为 0<br>对结果取反，并进行大小端处理</p></blockquote><h2 id="8-写代码"><a href="#8-写代码" class="headerlink" title="8.写代码"></a>8.写代码</h2><p>经过前面基础知识的铺垫，接下来的思路就比较清晰了。首先先找到一个合适的校验和算法，构建好ICMP回送请求报文后，将其发送出去（TTL依次递增，每次发三个包）。计算好阻塞的时间，超出你设定的时间后（一般设置为3秒）就认定为超时，以*代替。对返回的ICMP报文进行解析并判断，根据报文类型的不同进行不同的处理。</p>]]></content>
      
      
      
        <tags>
            
            <tag> traceroute icmp python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2021/09/16/hexo-bu-shu-wang-zhan-yu-dao-de-yi-xie-wen-ti/"/>
      <url>/2021/09/16/hexo-bu-shu-wang-zhan-yu-dao-de-yi-xie-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo部署网站遇到的一些问题"><a href="#hexo部署网站遇到的一些问题" class="headerlink" title="hexo部署网站遇到的一些问题"></a>hexo部署网站遇到的一些问题</h1><p>1.绝对不要在主题目录里使用hexo g或hexo d,容易崩<br>2.当使用hexo g(d)更新内容时，出现了fatal: unable to access ‘<a href="https://github.com/.......&#39;">https://github.com/.......&#39;</a>: OpenSSL SSL_read: Connection was reset, errno 10054的错误<br>产生原因：一般是这是因为服务器的SSL证书没有经过第三方机构的签署，所以才报错，参考网上解决办法：解除ssl验证后，再次git即可。<br>即使用<code>git config --global http.sslVerify &quot;false&quot;</code></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

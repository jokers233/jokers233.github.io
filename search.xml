<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ubuntu改成桥接模式的一些尝试</title>
      <link href="/2021/09/17/ubuntu-gai-cheng-qiao-jie-mo-shi-de-yi-xie-chang-shi/"/>
      <url>/2021/09/17/ubuntu-gai-cheng-qiao-jie-mo-shi-de-yi-xie-chang-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="第一步：VMware的设置"><a href="#第一步：VMware的设置" class="headerlink" title="第一步：VMware的设置"></a>第一步：VMware的设置</h1><p>这一步事实上跟其他博客写的没多大差别</p><h2 id="1、首先在虚拟机-gt-设置-gt-网络适配器里选择桥接模式"><a href="#1、首先在虚拟机-gt-设置-gt-网络适配器里选择桥接模式" class="headerlink" title="1、首先在虚拟机-&gt;设置-&gt;网络适配器里选择桥接模式"></a>1、首先在虚拟机-&gt;设置-&gt;网络适配器里选择桥接模式</h2><p>（直接选就行，有些博客说要勾选“复制物理网络连接状态”，其实没必要）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>用python实现traceroute</title>
      <link href="/2021/09/16/yong-python-shi-xian-traceroute/"/>
      <url>/2021/09/16/yong-python-shi-xian-traceroute/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>本次用python实现traceroute，主要用到了socket,struct,select,还需要对ICMP报文有足够的了解，以及校验和算法的实现。</p><h2 id="2-ICMP协议"><a href="#2-ICMP协议" class="headerlink" title="2.ICMP协议"></a>2.ICMP协议</h2><p>TraceRoute程序的实现一般可基于ICMP和UDP两种协议来实现，这里我采用的是前者。</p><h2 id="2-1简介"><a href="#2-1简介" class="headerlink" title="2.1简介"></a>2.1简介</h2><p>ICMP（Internet Control Message Protocol），中文译作网际控制报文协议，它允许主机或路由器报告差错情况和提供有关异常情况的报告，其常用功能有：确认IP数据报是否成功送达目标地址、通知在发送过程中IP数据报被废弃的原因，改善网络设置等。<br>ICMP报文虽封装在IP数据报中，但它并不属于更高层协议，反而仍属于网络层协议。下面是网络层各协议的层次分布情况，其上下关系说明了协议之间的依赖关系（上面的高层协议依赖于下面的低层协议），比如说IP协议就依赖于ARP协议的地址解析功能，ICMP和IGMP协议就依赖于IP协议的交付功能。<br><img src="https://i.loli.net/2021/09/18/tTCO1Gf3WRboqAc.jpg" alt="ip层.jpg"></p><h2 id="2-2报文格式"><a href="#2-2报文格式" class="headerlink" title="2.2报文格式"></a>2.2报文格式</h2><p>下图是ICMP报文的格式，简单介绍了各字段占用字节的大小，接下来还需要详细介绍一下各字段表示的意义：</p><p>类型（type）：标识ICMP报文的类型。</p><p>代码（code）：用于进一步区分某种类型中的某种情况。</p><p>校验和（checksum）：用于保证ICMP报文的完整性和正确性。<br><img src="https://i.loli.net/2021/09/18/WKkGioC1YI5Vgad.jpg" alt="ICMP.jpg"></p><p>不同之处在于整个第二行的全部四个字节，其具体内容要根据ICMP报文类型的变化而具备不同意义：</p><p>当报文类型为回送请求时， 前两个字节表示id（标识符），后两个字节表示sequence（序列号）。</p><p>当报文类型为回送应答时，这四个字节会原封不动地返回源主机。</p><p>当报文类型为超时报文时，这四个字节必须强制填充为 0 。</p><p>当报文类型为参数错误时，第一个字节作为指针指向出错部分，后三个字节强制填充为 0 。</p><ul><li>注：ICMP报文需要计算校验和是由于：IP数据报计算的校验和只针对IP数据报首部有效，并不能确保数据部分一定进行无差错传输，类似地，TCP和UDP也需要自行计算校验和以确保数据部分的无差错传输。</li></ul><h2 id="2-3报文分类"><a href="#2-3报文分类" class="headerlink" title="2.3报文分类"></a>2.3报文分类</h2><p>ICMP报文主要分为两大类 - 差错报告报文和网络控制报文：差错报告报文由于责任重大，规定其数据区必须包括发生差错的IP数据报首部以及数据区的至少64比特，因为这些信息更够为源端采取差错处理措施提供依据。</p><p>网络控制报文又可分为两类 - 请求/应答报文和通知报文：其中请求/应答报文总是成对出现的，一个负责请求，一个负责应答，而通知报文顾名思义，则只负责建立一种单向的通知机制。</p><p>ICMP报文种类繁多，协议设计者按照层次将其划分为type和code两层结构，其中type字段表明ICMP报文的类型，code字段则提供了有关报文类型更为详细的信息，下面是不同type值所代表的意义：<br><img src="https://i.loli.net/2021/09/18/ihaJeBzLCmKwRO3.jpg" alt="ICMP报文类型.jpg"></p><p>确定了type之后，还需要确定code：如果当前type已经无需再进行细分的话，则置为 0 即可；但常见的诸如type为3、5、11、12 等的报文是还需细分的，具体的划分情况请看下表：</p><table><thead><tr><th>type</th><th>code</th><th>meaning</th><th>code</th><th>meaning</th></tr></thead><tbody><tr><td>03 - 目的站不可达</td><td>0</td><td>目的网络不可达</td><td>8</td><td>源主机隔离</td></tr><tr><td></td><td>1</td><td>目的主机不可达</td><td>9</td><td>禁止访问的网络</td></tr><tr><td></td><td>2</td><td>目的协议不可达</td><td>10</td><td>机制访问的主机</td></tr><tr><td></td><td>3</td><td>目的端口不可达</td><td>11</td><td>对特定TOS网络不可达</td></tr><tr><td></td><td>4</td><td>要求分段并置DF标志位</td><td>12</td><td>对特定TOS主机不可达</td></tr><tr><td></td><td>5</td><td>源路由失败</td><td>13</td><td>由于过滤，网络流量被禁止</td></tr><tr><td></td><td>6</td><td>目的网络未知</td><td>14</td><td>主机越权</td></tr><tr><td></td><td>7</td><td>目的主机未知</td><td>15</td><td>优先权终止生效</td></tr><tr><td>05  重定向</td><td>0</td><td>重定向网络</td><td>2</td><td>基于TOS的网络重定向</td></tr><tr><td></td><td>1</td><td>重定向主机</td><td>3</td><td>基于TOS的主机重定向</td></tr><tr><td>11 - 报文超时</td><td>0</td><td>TTL超时</td><td>1</td><td>分片重组超时</td></tr><tr><td>12 - 参数问题</td><td>0</td><td>IP数据报首部参数错误</td><td>2</td><td>不支持的长度</td></tr><tr><td></td><td>1</td><td>丢失必要选项</td><td></td><td></td></tr></tbody></table><ul><li>注：TOS（Type of Service），中文可译为请求的服务类型。</li></ul><h2 id="3-TraceRoute程序的基本原理是："><a href="#3-TraceRoute程序的基本原理是：" class="headerlink" title="3.TraceRoute程序的基本原理是："></a>3.TraceRoute程序的基本原理是：</h2><p>当路由器收到一份IP数据报，如果该报文的TTL字段是1，则意味着它在网路中的生存周期已经消耗殆尽，<br>本路由处理后还未到达目的主机的话，需要将该数据报丢弃，并给信源主机发送一份ICMP超时报文（包含该中间路由器的地址）。<br>这意味着：通过发送一份TTL字段为n的IP数据报给目的主机，就得到了该路径中的第n个路由器的IP地址。<br>那么我们使IP数据报的TTL字段值从1开始依次递增(一般最大不超过30)，就可以获得所有中间路由的ip地址。<br>当IP数据报到达目的主机时，由于已经到达目的主机，因此不会再发送ICMP超时报文了，而是ICMP应答报文。<br>通过区分收到的ICMP报文是超时报文（type=11）还是应答报文（type=0），以判断程序应该何时结束。</p><ul><li><p>因此，要实现一个traceroute程序，主要需要以下几大步骤<br>  1.创建原始套接字（注意：原始套接字需要管理员（root）权限，在linux下如果不用sudo运行，会报出<strong>PermissionError: [Errno 1] Operation not permitted</strong>的错误）</p><p>  2.构建ICMP报文,ICMP报文内容如下：<br>  ————————————————————————————————————————<br>  |type (8) | code (8) | checksum (16)   |<br>  ————————————————————————————————————————<br>  |        id (16)     |  seq (16)       |<br>  ————————————————————————————————————————</p><p>  3.选取合适的校验和算法，用于ICMP报文的构造</p></li></ul><h2 id="4-原始套接字"><a href="#4-原始套接字" class="headerlink" title="4.原始套接字"></a>4.原始套接字</h2><p>所谓套接字(Socket)，就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议根进行交互的接口。套接字可分为流式套接字，数据包套接字以及原始套接字。<br>原始套接字与标准套接字(标准套接字指的是流式套接字和数据报套接字)的区别在于：原始套接字可以读写内核没有处理的IP数据包，而流式套接字只能读取TCP协议的数据，数据报套接字只能读取UDP协议的数据。因此，如果要访问其他协议发送的数据必须使用原始套接字。而本次使用的是ICMP协议（运行在网络层），故只能使用原始套接字来实现功能。</p><blockquote><p>AF_INET: ipv4 格式的 ip 地址<br>AF_INET6: ipv6 格式的 ip 地址</p></blockquote><h2 id="5-字节序"><a href="#5-字节序" class="headerlink" title="5.字节序"></a>5.字节序</h2><p>在各种计算机体系结构中，对于字节、字等的存储机制有所不同，因而引发了计算机通信领域中一个很重要的问题，即通信双方交流的信息单元（比特、字节、字、双字等等）应该以什么样的顺序进行传送。如果不达成一致的规则，通信双方将无法进行正确的编 / 译码从而导致通信失败。</p><p>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，也就是说对于单字符来说是没有字节序问题的，字符串是单字符的集合，因此字符串也没有字节序问题。</p><p>目前在各种体系的计算机中通常采用的字节存储机制主要有两种：Big-Endian 和 Little-Endian</p><ul><li>Little-Endian -&gt; 主机字节序 (小端)</li></ul><blockquote><p>数据的低位字节存储到内存的低地址位 , 数据的高位字节存储到内存的高地址位<br>我们使用的 PC 机，数据的存储默认使用的是小端</p></blockquote><ul><li>Big-Endian -&gt; 网络字节序 (大端)</li></ul><blockquote><p>数据的低位字节存储到内存的高地址位 , 数据的高位字节存储到内存的低地址位<br>套接字通信过程中操作的数据都是大端存储的，包括：接收/发送的数据、IP地址、端口。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> traceroute icmp python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2021/09/16/hexo-bu-shu-wang-zhan-yu-dao-de-yi-xie-wen-ti/"/>
      <url>/2021/09/16/hexo-bu-shu-wang-zhan-yu-dao-de-yi-xie-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo部署网站遇到的一些问题"><a href="#hexo部署网站遇到的一些问题" class="headerlink" title="hexo部署网站遇到的一些问题"></a>hexo部署网站遇到的一些问题</h1><h2 id="1-绝对不要在主题目录里使用hexo-g或hexo-d-容易崩"><a href="#1-绝对不要在主题目录里使用hexo-g或hexo-d-容易崩" class="headerlink" title="1.绝对不要在主题目录里使用hexo g或hexo d,容易崩"></a>1.绝对不要在主题目录里使用hexo g或hexo d,容易崩</h2><h2 id="2-当使用hexo-g-d-更新内容时，出现了fatal-unable-to-access-‘https-github-com-39-OpenSSL-SSL-read-Connection-was-reset-errno-10054的错误"><a href="#2-当使用hexo-g-d-更新内容时，出现了fatal-unable-to-access-‘https-github-com-39-OpenSSL-SSL-read-Connection-was-reset-errno-10054的错误" class="headerlink" title="2.当使用hexo g(d)更新内容时，出现了fatal: unable to access ‘https://github.com/.......&#39;: OpenSSL SSL_read: Connection was reset, errno 10054的错误"></a>2.当使用hexo g(d)更新内容时，出现了fatal: unable to access ‘<a href="https://github.com/.......&#39;">https://github.com/.......&#39;</a>: OpenSSL SSL_read: Connection was reset, errno 10054的错误</h2><p>产生原因：一般是这是因为服务器的SSL证书没有经过第三方机构的签署，所以才报错，参考网上解决办法：解除ssl验证后，再次git即可。<br>即使用<code>git config --global http.sslVerify &quot;false&quot;</code></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

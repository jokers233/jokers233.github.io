<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ubuntu改成桥接模式的一些尝试</title>
      <link href="/2021/09/17/ubuntu-gai-cheng-qiao-jie-mo-shi-de-yi-xie-chang-shi/"/>
      <url>/2021/09/17/ubuntu-gai-cheng-qiao-jie-mo-shi-de-yi-xie-chang-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="第一步：VMware的设置"><a href="#第一步：VMware的设置" class="headerlink" title="第一步：VMware的设置"></a>第一步：VMware的设置</h1><p>这一步事实上跟其他博客写的没多大差别</p><h2 id="1、首先在虚拟机-gt-设置-gt-网络适配器里选择桥接模式"><a href="#1、首先在虚拟机-gt-设置-gt-网络适配器里选择桥接模式" class="headerlink" title="1、首先在虚拟机-&gt;设置-&gt;网络适配器里选择桥接模式"></a>1、首先在虚拟机-&gt;设置-&gt;网络适配器里选择桥接模式</h2><p>（直接选就行，有些博客说要勾选“复制物理网络连接状态”，其实没必要）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>用python实现traceroute</title>
      <link href="/2021/09/16/yong-python-shi-xian-traceroute/"/>
      <url>/2021/09/16/yong-python-shi-xian-traceroute/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>本次用python实现traceroute，主要用到了socket,struct,select,还需要对ICMP报文有足够的了解，以及校验和算法的实现。</p><h1 id="2-ICMP协议"><a href="#2-ICMP协议" class="headerlink" title="2.ICMP协议"></a>2.ICMP协议</h1><p>TraceRoute程序的实现一般可基于ICMP和UDP两种协议来实现，这里我采用的是前者。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ICMP（Internet Control Message Protocol），中文译作网际控制报文协议，它允许主机或路由器报告差错情况和提供有关异常情况的报告，其常用功能有：确认IP数据报是否成功送达目标地址、通知在发送过程中IP数据报被废弃的原因，改善网络设置等。<br>ICMP报文虽封装在IP数据报中，但它并不属于更高层协议，反而仍属于网络层协议。下面是网络层各协议的层次分布情况，其上下关系说明了协议之间的依赖关系（上面的高层协议依赖于下面的低层协议），比如说IP协议就依赖于ARP协议的地址解析功能，ICMP和IGMP协议就依赖于IP协议的交付功能。<br><img src="https://i.loli.net/2021/09/18/tTCO1Gf3WRboqAc.jpg" alt="ip层.jpg"></p><p>报文格式<br>下图是ICMP报文的格式，简单介绍了各字段占用字节的大小，接下来还需要详细介绍一下各字段表示的意义：</p><p>类型（type）：标识ICMP报文的类型。</p><p>代码（code）：用于进一步区分某种类型中的某种情况。</p><p>校验和（checksum）：用于保证ICMP报文的完整性和正确性。<br><img src="https://i.loli.net/2021/09/18/WKkGioC1YI5Vgad.jpg" alt="ICMP.jpg"></p><p>不同之处在于整个第二行的全部四个字节，其具体内容要根据ICMP报文类型的变化而具备不同意义：</p><p>当报文类型为回送请求时， 前两个字节表示id（标识符），后两个字节表示sequence（序列号）。</p><p>当报文类型为回送应答时，这四个字节会原封不动地返回源主机。</p><p>当报文类型为超时报文时，这四个字节必须强制填充为 0 。</p><p>当报文类型为参数错误时，第一个字节作为指针指向出错部分，后三个字节强制填充为 0 。</p><h1 id="TraceRoute程序的基本原理是："><a href="#TraceRoute程序的基本原理是：" class="headerlink" title="TraceRoute程序的基本原理是："></a>TraceRoute程序的基本原理是：</h1><p>当路由器收到一份IP数据报，如果该报文的TTL字段是1，则意味着它在网路中的生存周期已经消耗殆尽，<br>本路由处理后还未到达目的主机的话，需要将该数据报丢弃，并给信源主机发送一份ICMP超时报文（包含该中间路由器的地址）。<br>这意味着：通过发送一份TTL字段为n的IP数据报给目的主机，就得到了该路径中的第n个路由器的IP地址。<br>那么我们使IP数据报的TTL字段值从1开始依次递增，就可以获得所有中间路由的ip地址。<br>当IP数据报到达目的主机时，由于已经到达目的主机，因此不会再发送ICMP超时报文了，而是ICMP应答报文。<br>通过区分收到的ICMP报文是超时报文（type=11）还是应答报文（type=0），以判断程序应该何时结束。</p><ul><li>因此，要实现一个traceroute程序，主要需要以下几大步骤<br>  1.创建原始套接字（注意：原始套接字需要管理员（root）权限，在linux下如果不用sudo运行，会报出<strong>PermissionError: [Errno 1] Operation not permitted</strong>的错误）<br>  2.构建ICMP报文,ICMP报文内容如下：<br>  ————————————————————————————————————————<br>  |type (8) | code (8) | checksum (16)   |<br>  ————————————————————————————————————————<br>  |        id (16)     |  seq (16)       |<br>  ————————————————————————————————————————<br>  3.选取合适的校验和算法，用于ICMP报文的构造</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> traceroute icmp python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2021/09/16/hexo-bu-shu-wang-zhan-yu-dao-de-yi-xie-wen-ti/"/>
      <url>/2021/09/16/hexo-bu-shu-wang-zhan-yu-dao-de-yi-xie-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo部署网站遇到的一些问题"><a href="#hexo部署网站遇到的一些问题" class="headerlink" title="hexo部署网站遇到的一些问题"></a>hexo部署网站遇到的一些问题</h1><h2 id="1-绝对不要在主题目录里使用hexo-g或hexo-d-容易崩"><a href="#1-绝对不要在主题目录里使用hexo-g或hexo-d-容易崩" class="headerlink" title="1.绝对不要在主题目录里使用hexo g或hexo d,容易崩"></a>1.绝对不要在主题目录里使用hexo g或hexo d,容易崩</h2><h2 id="2-当使用hexo-g-d-更新内容时，出现了fatal-unable-to-access-‘https-github-com-39-OpenSSL-SSL-read-Connection-was-reset-errno-10054的错误"><a href="#2-当使用hexo-g-d-更新内容时，出现了fatal-unable-to-access-‘https-github-com-39-OpenSSL-SSL-read-Connection-was-reset-errno-10054的错误" class="headerlink" title="2.当使用hexo g(d)更新内容时，出现了fatal: unable to access ‘https://github.com/.......&#39;: OpenSSL SSL_read: Connection was reset, errno 10054的错误"></a>2.当使用hexo g(d)更新内容时，出现了fatal: unable to access ‘<a href="https://github.com/.......&#39;">https://github.com/.......&#39;</a>: OpenSSL SSL_read: Connection was reset, errno 10054的错误</h2><p>产生原因：一般是这是因为服务器的SSL证书没有经过第三方机构的签署，所以才报错，参考网上解决办法：解除ssl验证后，再次git即可。<br>即使用<code>git config --global http.sslVerify &quot;false&quot;</code></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
